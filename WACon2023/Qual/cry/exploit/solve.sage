from random import randint

from Crypto.Util.number import isPrime, long_to_bytes
from tqdm import tqdm


def dbl_xz(P, A, B):
    """
    From http://hyperelliptic.org/EFD/g1p/auto-shortw-xz.html#doubling-dbl-2002-it-2
    """
    X1, Z1 = P

    T1 = X1 ^ 2
    T2 = Z1 ^ 2
    T3 = A * T2
    T4 = T1 - T3
    T5 = T4 ^ 2
    T6 = B * T2
    T7 = X1 * Z1
    T8 = T6 * T7
    T9 = 8 * T8
    X3 = T5 - T9
    T10 = T1 + T3
    T11 = T7 * T10
    T12 = T6 * T2
    T13 = T11 + T12
    Z3 = 4 * T13

    return X3, Z3


def add_xz(P1, P2, X1, A, B):
    """
    From http://hyperelliptic.org/EFD/g1p/auto-shortw-xz.html#diffadd-mdadd-2002-it-3
    """
    X2, Z2 = P1
    X3, Z3 = P2

    T1 = X2 * X3
    T2 = Z2 * Z3
    T3 = X2 * Z3
    T4 = Z2 * X3
    T5 = A * T2
    T6 = T1 - T5
    T7 = T6 ^ 2
    T8 = B * T2
    T9 = 4 * T8
    T10 = T3 + T4
    T11 = T9 * T10
    T12 = T7 - T11
    X5 = T12
    T13 = T3 - T4
    T14 = T13 ^ 2
    Z5 = X1 * T14

    return X5, Z5


def ladder(n, x0, A, B):
    l = n.nbits()
    x1, z1 = x0, 1
    x2, z2 = dbl_xz((x1, z1), A, B)
    R = [(x1, z1), (x2, z2)]
    for i in range(2, l + 1):
        bit = (n >> (l - i)) & 1
        R[1 - bit] = add_xz(R[0], R[1], x0, A, B)
        R[bit] = dbl_xz(R[bit], A, B)
    return R[0]


def factor(n):
    def generator():
        while True:
            yield

    x = polygen(ZZ)
    Zi = ZZ.extension(x**2 + 1, "i")
    i = Zi.gens()[1]
    Ri = Zi.quotient_ring(Zi.ideal(n), "j")
    for _ in tqdm(generator()):
        Gx = 1  # for not calculating inverse -> this works well!
        Gy = randint(1, n) + randint(1, n) * i
        b = 0
        a = Gy**2 - Gx**3  # * invmod(Gx, n)
        E = EllipticCurve(Ri, [a, b])
        G = E(Gx, Gy)
        nG = ladder(n, Ri(G[0]), Ri(a), Ri(b))
        if (d := gcd(n, nG[1].lift().norm())) > 1:
            if d == 2:
                continue
            assert n % d == 0 and n != d
            return Integer(d)
    assert False, "factor failed"


if __name__ == "__main__":
    e = 65537

    with open("dist/output", "r") as f:
        [n0, n1, n2, c] = [Integer(line.split()[-1]) for line in f.readlines()]

    ns = [n2, n1, n0]
    ds = []
    for n in ns:
        _p = factor(n)
        assert _p % 2 == 0
        p = _p // 2
        assert isPrime(p)
        q = p**2 + 1
        assert q % 2 == 0 and isPrime(q // 2)
        r = n // (p * q)
        assert isPrime(r)
        assert p * q * r == n
        d = pow(e, -1, (p - 1) * (q // 2 - 1) * (r - 1))
        ds.append(d)

    t = c
    for d, n in zip(ds, ns):
        t = pow(t, d, n)

    m = long_to_bytes(t)
    assert b"WACON2023{" in m
    print(m)
