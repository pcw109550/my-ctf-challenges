#!/usr/bin/env sage

import argparse
import sys

BITLENGTH = 2048

HINT = 0b001011
# HINT = 0b110111

def print_fplll_format(M):
    m, n = M.dimensions()
    s = "["
    for i in range(m):
        s += "["
        for j in range(n):
            s += str(M[i, j])
            if j < n - 1:
                s += " "
        s += "]"
        print(s)
        s = ""
    print("]")


def read_fplll_format():
    rows = []
    for line in sys.stdin:
        line = line.lstrip("[").rstrip("\n").rstrip("]")
        if len(line) == 0:
            break

        row = [int(x) for x in line.split(" ") if len(x) > 0 and x != "]"]
        rows += [row]
    m = len(rows)
    n = len(rows[0])
    for row in rows:
        assert len(row) == n

    L = Matrix(ZZ, m, n)
    for i in range(m):
        for j in range(n):
            L[i, j] = rows[i][j]
    return L


def get_kt(unknown_bits):
    assert BITLENGTH == 2048
    # Lookup table for optimal Coppersmith parameters
    kt_lut = [
        [340, (1, 2)],
        [408, (2, 3)],
        [437, (3, 4)],
        [454, (4, 5)],
        [464, (5, 6)],
        [471, (6, 7)],
        [476, (7, 8)],
        [480, (8, 9)],
        [484, (9, 11)],
        [486, (10, 11)],
        [488, (11, 12)],
        [490, (12, 13)],
        [492, (13, 15)],
        [493, (14, 15)],
        [494, (15, 16)],
        [495, (16, 17)],
        [496, (17, 18)],
        [497, (18, 19)],
        [498, (20, 21)],
        [499, (21, 22)],
        [500, (23, 24)],
        [501, (26, 27)],
        [502, (29, 30)],
        [503, (32, 33)],
        [504, (37, 38)],
        [505, (43, 44)],
        [506, (52, 53)],
        [507, (65, 66)],
        [508, (87, 88)],
        [509, (132, 133)],
        [510, (271, 273)],
    ]
    for allowed_unknown_bits, (k, t) in kt_lut:
        if allowed_unknown_bits >= unknown_bits + 1:
            return k, t
    raise "Not allowed"


def construct_lattice(prob, answer=None):
    N, p_msb, unknown_bits = prob
    k, t = get_kt(unknown_bits - 1)

    PR = PolynomialRing(ZZ, "x")
    x = PR.gens()[0]
    f = x + pow(2, -1, N) * (p_msb + 1) % N

    if answer is not None:
        # Check that f has a root r mod p
        p, q = answer
        r = (p - p_msb - 1) // 2
        assert f(r) % p == 0

    # Build table of powers of f and N
    f_powers = [f**0]
    N_powers = [N**0]
    for i in range(1, k + 1):
        f_powers += [f_powers[-1] * f]
        N_powers += [N_powers[-1] * N]

    aux_polys = []
    for i in range(k):
        g_i = N_powers[k - i] * f_powers[i]
        aux_polys += [g_i]

    for i in range(t):
        g_i = x**i * f_powers[k]
        aux_polys += [g_i]

    if answer is not None:
        # Check that all auxiliary polynomials are 0 mod p**k
        pk = p**k
        for g_i in aux_polys:
            assert g_i(r) % pk == 0

    dimension = t + k
    R = 2 ** (unknown_bits - 1)
    L = Matrix(ZZ, dimension, dimension)
    for i, g_i in enumerate(aux_polys):
        scaled_g = g_i(R * x)

        coefs = scaled_g.list()
        for j, coef in enumerate(coefs):
            L[i, j] = coef

    return L


def solve_from_reduced_lattice(unknown_bits, L_red, answer=None):
    # Get single polynomial
    PR = PolynomialRing(ZZ, "x")
    x = PR.gens()[0]

    R = 2 ** (unknown_bits - 1)
    h = PR(L_red[0].list())(x / R)

    r = h.roots(ZZ)[0][0]
    assert h(r) == 0
    if abs(r) > R:
        raise "Recovery failed."
    lsbs = int(r)
    return lsbs


def attack_generate_only(N, p_msb, unknown_bits):
    # Generate the lattice and print to stdout
    hint = HINT << unknown_bits
    problem = N, p_msb + hint, unknown_bits

    print("p_msb with hint", bin(p_msb + hint), file=sys.stderr)

    L = construct_lattice(problem)
    print_fplll_format(L)


def attack_post_reduction_only(N, p_msb, unknown_bits):
    L_red = read_fplll_format()
    p_lsb = solve_from_reduced_lattice(unknown_bits, L_red)
    print(f"Recovered LSBs are {hex(2 * p_lsb + 1)}")

    p = p_msb + (HINT << unknown_bits) + 2 * p_lsb + 1
    assert N % p == 0
    q = N // p
    print(f"{p = }", file=sys.stderr)
    print(f"{q = }", file=sys.stderr)


def main():
    N = 24712135189687942739677490021030751776088469214818275631687482073531676912880823269667196936095460153002434759403063429337125873794523587731746689517070810687221399532024093572951282737818446579992570629531618780373767724789390101166147862982539311016801595612323156816999866783427829783286164172896802725820761659256555627406518829192800217880692359914672894220547306033679060066475600137205045054015651689487444267401130160872050085589597109014374199731072611044277806027332254214020499883131062627540945260814416104971893858787291926267157394988131329441246648393933117451348643609850156730059817506513924523851733
    p_msb = 161405912451824860188834725646055524173328544131300133372580621368926433914138476338787007253318242142454894032713487340762003643551953941809023233323836630063065828499586237941251339865726273353740523275987884928619323490566227483094269770052935277592758770273832919929071652425379016974435907024060290170880
    unknown_bits = 506

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--step-1", action="store_true", help="Output unreduced lattice"
    )
    parser.add_argument(
        "--step-2", action="store_true", help="Solve from reduced lattice"
    )
    args = parser.parse_args()

    unknown_bits = 506

    if args.step_1 and (not args.step_2):
        attack_generate_only(N, p_msb, unknown_bits)
    elif (not args.step_1) and args.step_2:
        attack_post_reduction_only(N, p_msb, unknown_bits)
    else:
        assert False


if __name__ == "__main__":
    main()
