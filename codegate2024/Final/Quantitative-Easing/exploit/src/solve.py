from __future__ import annotations

import hashlib
import json
import secrets
import sys
from typing import Any, Dict, List

import pwn
from fastecdsa.curve import secp256k1
from fastecdsa.point import Point

from rangeproofs import (AggregNIRangeProver, AggregNIRangeProverForgery,
                         AggregRangeVerifier, NIRangeProver, Proof,
                         RangeVerifier)
from utils import (ModP, b64_to_point, commitment, mod_hash, point_to_b64,
                   point_to_bytes)

DEBUG = False

# pwn.context.log_level = "DEBUG"
if DEBUG:
    tn = pwn.process(["/usr/bin/python3", "MW.py"])
else:
    IP, PORT = "54.180.139.83", 13337
    tn = pwn.remote(IP, PORT)
    def PoW():
        import subprocess
        tn.recvuntil(b"python3 <(curl -sSL https://goo.gle/kctf-pow) solve ")
        token = tn.recvline(keepends=False).decode()
        pwn.log.info(f"PoW token = {token}")
        result = subprocess.run(f'bash -c "python3 <(curl -sSL https://goo.gle/kctf-pow) solve {token}"', shell=True, capture_output=True).stdout.strip()
        pwn.log.info(f"PoW solution = {result.decode()}")
        tn.sendlineafter(b"Solution? ", result)
        validation = tn.recvline(keepends=False).decode()
        pwn.log.info(f"PoW {validation = }")
    PoW()

def recv_msg() -> Dict[str, Any]:
    data = tn.recvline()
    return json.loads(data)


def send_msg(data: Dict):
    tn.sendline(json.dumps(data).encode())


class RangeProofFactory:
    @staticmethod
    def aggRangeProve(
        vs: List[int], gammas: List[int], seed: bytes
    ) -> AggregNIRangeProver:
        vs = [ModP(v, order) for v in vs]
        gammas = [ModP(gamma, order) for gamma in gammas]
        return AggregNIRangeProver(vs, n, G, H, Gs, Hs, gammas, U, CURVE, seed)

    @staticmethod
    def aggRangeProveForgery(vs: List[int], gammas: List[int], seed: bytes):
        vs = [ModP(v, order) for v in vs]
        gammas = [ModP(gamma, order) for gamma in gammas]
        return AggregNIRangeProverForgery(vs, n, G, H, Gs, Hs, gammas, U, CURVE, seed)

    @staticmethod
    def aggRangeVerify(Vs: List[Point], proof: Proof) -> AggregRangeVerifier:
        return AggregRangeVerifier(Vs, G, H, Gs, Hs, U, proof)

    @staticmethod
    def rangeProve(v: int, gamma: int, seed: bytes) -> NIRangeProver:
        v = ModP(v, order)
        gamma = ModP(gamma, order)
        return NIRangeProver(v, n, G, H, Gs[:n], Hs[:n], gamma, U, CURVE, seed)

    @staticmethod
    def rangeVerify(V: Point, proof: Proof) -> RangeVerifier:
        return RangeVerifier(V, G, H, Gs[:n], Hs[:n], U, proof)


class ProtocolParam:
    def __init__(
        self,
        G: Point,
        H: Point,
        U: Point,
        Gs: List[Point],
        Hs: List[Point],
        n: int,
        m: int,
    ):
        self.G = G
        self.H = H
        self.U = U
        self.Gs = Gs
        self.Hs = Hs
        self.n = n
        self.m = m

    def to_dict(self) -> Dict[str, Any]:
        return {
            "G": point_to_b64(self.G).decode(),
            "H": point_to_b64(self.H).decode(),
            "U": point_to_b64(self.U).decode(),
            "Gs": [point_to_b64(point).decode() for point in self.Gs],
            "Hs": [point_to_b64(point).decode() for point in self.Hs],
            "n": self.n,
            "m": self.m,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ProtocolParam":
        G = b64_to_point(data["G"].encode())
        H = b64_to_point(data["H"].encode())
        U = b64_to_point(data["U"].encode())
        Gs = [b64_to_point(point.encode()) for point in data["Gs"]]
        Hs = [b64_to_point(point.encode()) for point in data["Hs"]]
        n = data["n"]
        m = data["m"]

        return cls(G=G, H=H, U=U, Gs=Gs, Hs=Hs, n=n, m=m)


class Signature:
    def __init__(self, s: ModP, R: Point):
        self.s = s
        self.R = R

    def to_dict(self) -> Dict[str, Any]:
        return {
            "s": self.s.to_dict(),
            "R": point_to_b64(self.R).decode(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> Signature:
        s = ModP.from_dict(data["s"])
        R = b64_to_point(data["R"].encode())
        return cls(s=s, R=R)


class Kernel:
    def __init__(self, public_excess_final: Point, sig: Signature, tx_fee: int):
        self.public_excess_final = public_excess_final
        self.sig = sig
        self.tx_fee = tx_fee

    def to_dict(self) -> Dict[str, Any]:
        return {
            "public_excess_final": point_to_b64(self.public_excess_final).decode(),
            "sig": self.sig.to_dict(),
            "tx_fee": self.tx_fee,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Kernel":
        public_excess_final = b64_to_point(data["public_excess_final"].encode())
        sig = Signature.from_dict(data["sig"])
        tx_fee = data["tx_fee"]
        return cls(public_excess_final=public_excess_final, sig=sig, tx_fee=tx_fee)


class Body:
    def __init__(
        self,
        input_commitment: Point,
        change_commitment: Point,
        output_commitment: Point,
    ):
        self.input_commitment = input_commitment
        self.change_commitment = change_commitment
        self.output_commitment = output_commitment

    def to_dict(self) -> Dict[str, Any]:
        return {
            "input": point_to_b64(self.input_commitment).decode(),
            "outputs": {
                "change": point_to_b64(self.change_commitment).decode(),
                "output": point_to_b64(self.output_commitment).decode(),
            },
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> Body:
        input_commitment = b64_to_point(data["input"].encode())
        change_commitment = b64_to_point(data["outputs"]["change"].encode())
        output_commitment = b64_to_point(data["outputs"]["output"].encode())
        return cls(
            input_commitment=input_commitment,
            change_commitment=change_commitment,
            output_commitment=output_commitment,
        )


class TransactionProof:
    def __init__(self, sender_proof: Proof, receiver_proof: Proof):
        self.sender_proof = sender_proof
        self.receiver_proof = receiver_proof

    def to_dict(self) -> Dict[str, Any]:
        return {
            "sender_proof": self.sender_proof.to_dict(),
            "receiver_proof": self.receiver_proof.to_dict(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> TransactionProof:
        sender_proof = Proof.from_dict(data["sender_proof"])
        receiver_proof = Proof.from_dict(data["receiver_proof"])
        return cls(sender_proof=sender_proof, receiver_proof=receiver_proof)


class Transaction:
    def __init__(self, kernel: Kernel, body: Body, proof: TransactionProof):
        self.kernel = kernel
        self.body = body
        self.proof = proof

    def to_dict(self) -> Dict[str, Any]:
        return {
            "kernel": self.kernel.to_dict(),
            "body": self.body.to_dict(),
            "proof": self.proof.to_dict(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> Transaction:
        kernel = Kernel.from_dict(data["kernel"])
        body = Body.from_dict(data["body"])
        proof = TransactionProof.from_dict(data["proof"])
        return cls(kernel=kernel, body=body, proof=proof)


class AgentRequest:
    def __init__(
        self,
        input_commitment: Point,
        change_commitment: Point,
        public_nonce: Point,
        public_excess: Point,
        tx_fee: int,
        transfer_value: int,
        proof: Proof,
    ):
        self.input_commitment = input_commitment
        self.change_commitment = change_commitment
        self.public_nonce = public_nonce
        self.public_excess = public_excess
        self.tx_fee = tx_fee
        self.transfer_value = transfer_value
        self.proof = proof

    def to_dict(self) -> Dict[str, Any]:
        return {
            "input_commitment": point_to_b64(self.input_commitment).decode(),
            "change_commitment": point_to_b64(self.change_commitment).decode(),
            "public_nonce": point_to_b64(self.public_nonce).decode(),
            "public_excess": point_to_b64(self.public_excess).decode(),
            "tx_fee": self.tx_fee,
            "transfer_value": self.transfer_value,
            "proof": self.proof.to_dict(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> AgentRequest:
        """Deserialize an AgentRequest object from a dictionary."""
        input_commitment = b64_to_point(data["input_commitment"].encode())
        change_commitment = b64_to_point(data["change_commitment"].encode())
        public_nonce = b64_to_point(data["public_nonce"].encode())
        public_excess = b64_to_point(data["public_excess"].encode())
        tx_fee = data["tx_fee"]
        transfer_value = data["transfer_value"]
        proof = Proof.from_dict(data["proof"])
        assert isinstance(tx_fee, int) and isinstance(transfer_value, int)

        return cls(
            input_commitment,
            change_commitment,
            public_nonce,
            public_excess,
            tx_fee,
            transfer_value,
            proof,
        )


class AgentResponse:
    def __init__(
        self,
        output_commitment: Point,
        public_nonce: Point,
        signature: ModP,
        public_key: Point,
        proof: Proof,
    ):
        self.output_commitment = output_commitment
        self.public_nonce = public_nonce
        self.signature = signature
        self.public_key = public_key
        self.proof = proof

    def to_dict(self) -> Dict[str, Any]:
        """Serialize the AgentResponse object to a dictionary."""
        return {
            "output_commitment": point_to_b64(self.output_commitment).decode(),
            "public_nonce": point_to_b64(self.public_nonce).decode(),
            "signature": self.signature.to_dict(),
            "public_key": point_to_b64(self.public_key).decode(),
            "proof": self.proof.to_dict(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> AgentResponse:
        """Deserialize an AgentResponse object from a dictionary."""
        output_commitment = b64_to_point(data["output_commitment"].encode())
        public_nonce = b64_to_point(data["public_nonce"].encode())
        signature = ModP.from_dict(data["signature"])
        public_key = b64_to_point(data["public_key"].encode())
        proof = Proof.from_dict(data["proof"])

        return cls(output_commitment, public_nonce, signature, public_key, proof)


class Agent:
    def __init__(self, name: bytes, value: int, pk: int):
        self.name = name
        self.value = value
        self.pk = pk

        self.new_pk = None

        self.nonce = None
        self.excess = None

    # Alice prepares the transaction
    def request(self, tx_fee: int, transfer_value: int) -> dict:
        k1 = secrets.randbelow(order)
        input_commitment = commitment(G, H, self.value, self.pk)
        change_commitment = commitment(G, H, self.value - tx_fee - transfer_value, k1)

        # sanity check range proof
        proof = RangeProofFactory.aggRangeProve(
            [self.value, self.value - tx_fee - transfer_value], [self.pk, k1], self.name
        ).prove()
        proof = Proof.from_dict(proof.to_dict())
        assert RangeProofFactory.aggRangeVerify(
            [input_commitment, change_commitment], proof
        ).verify()

        excess = k1 - self.pk
        public_excess = excess * H
        assert (
            public_excess
            == -input_commitment + change_commitment + (transfer_value + tx_fee) * G
        )
        self.new_pk = k1
        r_a = secrets.randbelow(order)
        R_a = r_a * H

        request = AgentRequest(
            input_commitment=input_commitment,
            change_commitment=change_commitment,
            public_nonce=R_a,
            public_excess=public_excess,
            tx_fee=tx_fee,
            transfer_value=transfer_value,
            proof=proof,
        )

        data = {}
        data["sender"] = request.to_dict()

        self.nonce = r_a
        self.excess = excess
        return data

    # Alice prepares the transaction
    def request_with_forgery(self, tx_fee: int, transfer_value: int) -> dict:
        k1 = secrets.randbelow(order)
        # input_commitment = commitment(G, H, self.value, self.pk)
        # change_commitment = commitment(G, H, self.value - tx_fee - transfer_value, k1)

        vs = [self.value, self.value - tx_fee - transfer_value]
        prover = RangeProofFactory.aggRangeProveForgery(vs, [self.pk, k1], self.name)
        proof = prover.prove()
        proof = Proof.from_dict(proof.to_dict())

        t1, t2 = prover.t1, prover.t2
        t1_, t2_ = prover.t1_, prover.t2_
        x, z = prover.x, prover.z

        # Goal: Preserve vs[0]
        q = int(CURVE.q)
        zqu_inv = pow(z * z * z, -1, q)
        v_ = vs[1]
        v_ += (t1 - t1_) * x * zqu_inv
        v_ += (t2 - t2_) * x * x * zqu_inv
        vs_ = [vs[0], v_]

        # vs_[0] - vs_[1] = C = transfer_value + tx_fee_forged
        # tx_fee_forged at this case cannot be controlled
        tx_fee_forged = (vs_[0] - vs_[1] - transfer_value) % q

        # forged commitments
        input_commitment = commitment(G, H, vs_[0], self.pk)
        change_commitment = commitment(G, H, vs_[1], k1)

        # sanity check range proof with forged commitments
        assert RangeProofFactory.aggRangeVerify(
            [input_commitment, change_commitment], proof
        ).verify()

        excess = k1 - self.pk
        public_excess = excess * H

        assert (
            public_excess
            == -input_commitment
            + change_commitment
            + (transfer_value + tx_fee_forged) * G
        )
        self.new_pk = k1
        r_a = secrets.randbelow(order)
        R_a = r_a * H

        request = AgentRequest(
            input_commitment=input_commitment,
            change_commitment=change_commitment,
            public_nonce=R_a,
            public_excess=public_excess,
            tx_fee=tx_fee_forged,
            transfer_value=transfer_value,
            proof=proof,
        )

        data = {}
        data["sender"] = request.to_dict()

        self.nonce = r_a
        self.excess = excess
        return data

    # Bob prepares his response
    def response(self, data: dict) -> dict:
        request = AgentRequest.from_dict(data["sender"])

        public_excess = request.public_excess
        input_commitment = request.input_commitment
        change_commitment = request.change_commitment
        R_a = request.public_nonce
        tx_fee = request.tx_fee
        transfer_value = request.transfer_value

        assert (
            public_excess
            == -input_commitment + change_commitment + (transfer_value + tx_fee) * G
        )
        # Spending key for bob
        k_b = self.pk
        output_commitment = commitment(G, H, transfer_value, k_b)

        # sanity check range proof
        proof = RangeProofFactory.rangeProve(transfer_value, k_b, self.name).prove()
        proof = Proof.from_dict(proof.to_dict())
        assert RangeProofFactory.rangeVerify(output_commitment, proof).verify()

        P_b = k_b * H
        r_b = secrets.randbelow(order)
        self.nonce = r_b

        R_b = r_b * H
        public_excess_final = public_excess + P_b
        e = calc_challenge(R_a + R_b, public_excess_final, tx_fee)
        s_b = r_b + e * k_b

        response = AgentResponse(
            output_commitment=output_commitment,
            public_nonce=R_b,
            signature=ModP(s_b, order),
            public_key=P_b,
            proof=proof,
        )

        data["receiver"] = response.to_dict()

        self.value = transfer_value
        return data

    # Alice completes the tx
    def finalize_tx(self, data: dict) -> dict:
        request = AgentRequest.from_dict(data["sender"])
        response = AgentResponse.from_dict(data["receiver"])

        R_a = request.public_nonce
        R_b = response.public_nonce
        public_excess = request.public_excess
        P_b = response.public_key
        s_b = response.signature
        tx_fee = request.tx_fee

        public_excess_final = public_excess + P_b
        e = calc_challenge(R_a + R_b, public_excess_final, tx_fee)
        s_a = self.nonce + e * self.excess
        # aggregate signs
        s = s_a + s_b
        R = R_a + R_b

        signature = Signature(s=s, R=R)
        kernel = Kernel(
            public_excess_final=public_excess_final,
            sig=signature,
            tx_fee=tx_fee,
        )
        body = Body(
            input_commitment=request.input_commitment,
            change_commitment=request.change_commitment,
            output_commitment=response.output_commitment,
        )
        proof = TransactionProof(
            sender_proof=request.proof,
            receiver_proof=response.proof,
        )

        return Transaction(kernel=kernel, body=body, proof=proof).to_dict()


def calc_challenge(R: Point, X: Point, f: int) -> int:
    msg = point_to_bytes(R) + point_to_bytes(X) + f.to_bytes(32, byteorder="big")
    e = mod_hash(msg, order).x
    return e


PROTOCOL_PARAM = ProtocolParam.from_dict(recv_msg())
pwn.log.info("Received Protocol Parameters")
CURVE = secp256k1
order = secp256k1.q
n, m = 16, 2
G = PROTOCOL_PARAM.G
H = PROTOCOL_PARAM.H
U = PROTOCOL_PARAM.U
Gs = PROTOCOL_PARAM.Gs
Hs = PROTOCOL_PARAM.Hs

tx_raw = recv_msg()
tx = Transaction.from_dict(tx_raw)
pwn.log.info("Received transaction")

k_b = recv_msg()["k_b"]
pwn.log.info("Received spending key")

fake_tx_fee = 20

# Bob prepares the transaction
bob_value = 200
transfer_value = 100
bob = Agent(b"bob", bob_value, k_b)
bob_data = bob.request_with_forgery(fake_tx_fee, transfer_value)
# bob_data = bob.request(fake_tx_fee, transfer_value)

# Spending key for alice
k_a = secrets.randbelow(order)
alice = Agent(b"Alice", 0, k_a)

alice_data = alice.response(bob_data)
tx_raw_2 = bob.finalize_tx(alice_data)

pwn.log.info("Sent transaction")
send_msg(tx_raw_2)

pwn.log.info("Check flag")
data = recv_msg()
print(data)
print(data["flag"])

tn.interactive()
