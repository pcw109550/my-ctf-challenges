diff --git a/SQISign.py b/SQISign.py
index f7b2b7b..640f515 100644
--- a/SQISign.py
+++ b/SQISign.py
@@ -119,6 +119,9 @@ class SQISign:
         # Secret commitment values
         # commitment_secrets = (ψ_ker, ψ, Iψ)
         self.commitment_secrets = None
+        
+        self.τ_prime_iso = None
+        self.result = []
 
     def keygen(self):
         """
@@ -191,6 +194,61 @@ class SQISign:
         τ_prime = IdealToIsogenyFromKLPT(
             Jτ, I_trivial, ϕ_trivial, I_prime=Iτ, end_close_to_E0=True
         )
+        
+        Es = []
+        kernels = []
+        domain_codomain_pair = []
+        for f in τ_prime.factors():
+            for i, k in enumerate(f.factors()):
+                domain_codomain_pair.append((k.domain(), k.codomain()))
+                domain = k.domain() 
+                pp = [domain.lift_x(x) for x in domain.division_polynomial(2).roots(multiplicities=False)]
+                found = False
+                for ppp in pp:
+                    if not found and domain.isogeny(ppp).codomain().j_invariant() == k.codomain().j_invariant():
+                        found = True
+                        kernels.append(ppp)
+                        assert domain.isogeny(kernels[-1]).codomain().is_isomorphic(k.codomain())
+                assert found
+                Es.append(k)
+
+        assert len(Es) == len(kernels)
+        
+        new_kernels = []
+        Es_new = []
+        for i in range(len(Es)):
+            kernel = None
+            if i == 0:
+                pp = [Es[i].domain().lift_x(x) for x in Es[i].domain().division_polynomial(2).roots(multiplicities=False)]
+                for ppp in pp:
+                    if not kernel and Es[i].domain().isogeny(ppp).codomain().j_invariant() == Es[i].codomain().j_invariant():
+                        kernel = ppp
+            else:
+                pp = [Es_new[i - 1].codomain().lift_x(x) for x in Es_new[i - 1].codomain().division_polynomial(2).roots(multiplicities=False)]
+                for ppp in pp:
+                    if not kernel and Es_new[i - 1].codomain().isogeny(ppp).codomain().j_invariant() == Es[i].codomain().j_invariant():
+                        kernel = ppp
+            assert kernel
+            new_kernels.append(kernel)
+            
+            if i == 0:
+                isogeny = Es[i].domain().isogeny(kernel)
+            else:
+                isogeny = Es_new[i - 1].codomain().isogeny(kernel)
+            
+            domain = isogeny.domain()
+            codomain = isogeny.codomain()
+            assert Es[i].domain().j_invariant() == domain.j_invariant()
+            assert Es[i].codomain().j_invariant() == codomain.j_invariant()
+            
+            if Es[i].codomain() != codomain:
+                Es_new.append(isogeny)
+            else:
+                Es_new.append(Es[i])
+        
+        self.τ_prime_iso = Es_new[-1]
+        self.result = [list(k) for k in new_kernels]
+    
         EA = τ_prime.codomain()
 
         # The isogeny τ_prime should have degree = n(Jτ)
@@ -229,7 +287,9 @@ class SQISign:
         """
         # Generate a random kernel
         # of order T_prime
-        P, Q = torsion_basis(E0, T_prime)
+        # P, Q = torsion_basis(E0, T_prime)
+        P, Q = torsion_basis(E0, T_prime, canonical=True)
+        x = 12341234
         x = randint(1, T_prime)
         ψ_ker = P + x * Q
 
@@ -262,7 +322,8 @@ class SQISign:
         # If x isn't supplied, generate a random x
         if x is None:
             x = randint(1, Dc)
-
+        x = 43214321
+        
         # Compute the kernel of the challenge isogeny
         ϕ_ker = P + x * Q
 
@@ -358,6 +419,55 @@ class SQISign:
 
         print(f"INFO [SQISign Response]: Computing the corresponding isogeny")
         σ = IdealToIsogenyFromKLPT(J, Jτ, τ_prime, K_prime=Iτ)
+        
+        Es = []
+        kernels = []
+        for f in σ.factors():
+            for i, k in enumerate(f.factors()):
+                EEEE = k.domain() 
+                pp = [EEEE.lift_x(x) for x in EEEE.division_polynomial(2).roots(multiplicities=False)]
+                found = False
+                for ppp in pp:
+                    if not found and EEEE.isogeny(ppp).codomain().j_invariant() == k.codomain().j_invariant():
+                        found = True
+                        kernels.append(ppp)
+                assert found
+                Es.append(k)
+        
+        new_kernels = []
+        Es_new = []
+        for i in range(len(Es)):
+            kernel = None
+            if i == 0:
+                pp = [self.τ_prime_iso.codomain().lift_x(x) for x in self.τ_prime_iso.codomain().division_polynomial(2).roots(multiplicities=False)]
+                for ppp in pp:
+                    if not kernel and self.τ_prime_iso.codomain().isogeny(ppp).codomain().j_invariant() == Es[i].codomain().j_invariant():
+                        kernel = ppp
+            else:
+                pp = [Es_new[i - 1].codomain().lift_x(x) for x in Es_new[i - 1].codomain().division_polynomial(2).roots(multiplicities=False)]
+                for ppp in pp:
+                    if not kernel and Es_new[i - 1].codomain().isogeny(ppp).codomain().j_invariant() == Es[i].codomain().j_invariant():
+                        kernel = ppp
+            assert kernel
+            new_kernels.append(kernel)
+            
+            if i == 0:
+                isogeny = self.τ_prime_iso.codomain().isogeny(kernel)
+            else:
+                isogeny = Es_new[i - 1].codomain().isogeny(kernel)
+            
+            domain = isogeny.domain()
+            codomain = isogeny.codomain()
+            assert Es[i].domain().j_invariant() == domain.j_invariant()
+            assert Es[i].codomain().j_invariant() == codomain.j_invariant()
+            
+            if Es[i].codomain() != codomain:
+                Es_new.append(isogeny)
+            else:
+                Es_new.append(Es[i])
+        
+        self.result += [list(k) for k in new_kernels]
+        
         print(f"INFO [SQISign Response]: Computed the isogeny EA → E2")
 
         print(f"INFO [SQISign Response]: Compressing the isogeny σ to a bitstring")
diff --git a/example_SQISign.sage b/example_SQISign.sage
index 84776bc..c3b7321 100644
--- a/example_SQISign.sage
+++ b/example_SQISign.sage
@@ -66,3 +66,57 @@ valid = verifier.verify_response(EA, E1, S, phi_ker)
 
 print_info(f"SQISign example worked: {valid}")
 print_info(f"SQISign took {time.time() - sqisign_time:5f}")
+
+from setup import E0, O0, Bτ, eτ, p, l, Dc, T_prime, ω, e, f_step_max
+
+x = var("x")
+Fp2 = GF(p**2, name="z2", modulus=x**2 + 1)
+z2 = Fp2.gen()
+Fp4 = Fp2.extension(2, name="z4")
+z4 = Fp4.gen()
+
+E0 = EllipticCurve(Fp4, [1, 0])
+E0.set_order((p**2 - 1) ** 2, num_checks=0)
+
+E0_j_invariant = E0.j_invariant()
+
+from tqdm import tqdm
+def cgl_inv(kernels):
+    prev_j_invariant = E0_j_invariant
+    j_invariant_set = set()
+    E = E0.isogeny(E0(0, 0)).codomain()
+    
+    result = []
+    for i, pp in tqdm(enumerate(kernels)):
+        x, y, _ = pp
+        kernel = E(x, y)
+        f = E.division_polynomial(2)
+
+        kernels = []
+        for cand in sorted([E.lift_x(x) for x in f.roots(multiplicities=False)]):
+            if E.isogeny(cand).codomain().j_invariant() != prev_j_invariant:
+                kernels.append(cand)
+        assert kernel in kernels
+        result.append(kernels.index(kernel))
+        
+        isogeny = E.isogeny(kernel)
+        domain = isogeny.domain()
+        domain_j_invariant = domain.j_invariant()
+        codomain = isogeny.codomain()
+        codomain_j_invariant = codomain.j_invariant()
+        assert domain_j_invariant != codomain_j_invariant
+        
+        prev_j_invariant = domain_j_invariant
+        E = codomain
+        
+        assert codomain_j_invariant not in j_invariant_set
+        j_invariant_set.add(codomain_j_invariant)
+        
+    return E.j_invariant(), result
+    
+print(prover.result)
+_, m = cgl_inv(prover.result[1:])
+print(m)
+assert len(m) == 1255
+assert len(m) >= 1024
+print(int("".join([str(c) for c in m]), 2))
